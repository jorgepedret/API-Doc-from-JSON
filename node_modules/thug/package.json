{
  "name": "thug",
  "description": "functional style object filtration and validation system",
  "version": "0.3.2",
  "author": {
    "name": "Brock Whitten",
    "email": "brock@sintaxi.com"
  },
  "keywords": [
    "validations",
    "filter",
    "orm"
  ],
  "main": "./thug.js",
  "scripts": {
    "test": "./node_modules/.bin/mocha --ignore-leaks test/*"
  },
  "devDependencies": {
    "mocha": "1.3.0",
    "should": "1.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/sintaxi/thug.git"
  },
  "engines": {
    "node": "*"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.github.com/sintaxi/thug/master/README.md"
    }
  ],
  "readme": "# thug\n\n## Why?\n\nThug was created to minimize the complexity of validating and altering an\nobject before writing it to a data store or performing an operation. Thug is\nnot an ORM but is ment to be a replacment for one. Thug is very small and\nworks on both the server or in a browser.\n\n## Instalation\n\nI always recomend you bundle your dependencies with your application. To do\nthis, create a `package.json` file in the root of your project with the\nminimum information...\n\n    {\n      \"name\": \"yourapplication\",\n      \"version\": \"0.1.0\",\n      \"dependencies\": {\n        \"thug\": \"0.3.2\"\n      }\n    }\n\nThen run the following command using npm...\n\n    npm install\n\nOR, if you just want to start playing with the library run...\n\n    npm install thug\n\n## Docs\n\nCreating a basic store using Thug ...\n\n    var store = new Thug()\n    \n    store.constructor.prototype.write = function(identifier, record, callback){\n      // store the record any way you wish\n      // fire callback with record\n    }\n\n    store.constructor.prototype.read = function(identifier, callback){\n      // retrieve the record\n      // invoke callback with record\n    }\n    \n    store.constructor.prototype.remove = function(identifier, callback){\n      // remove the record\n      // invoke callback with errors or null\n    }\n\nThis gives us three basic methods `set`, `get`, `valid` ...\n    \n    store.set(\"foo\", \"bar\", function(errors, record){\n      // errors => null\n      // record => \"bar\"\n    })\n    \n    store.get(\"foo\", function(record){\n      // record => \"bar\"\n    })\n    \n    store.validate(\"foo\", \"bar\", function(errors, record){\n      // errors => null\n      // record => \"bar\"\n    })\n\nWhat we have created is a basic key/value store using `Thug` nothing special\nyet. Thug has two basic building blocks for you to use `filters` and\n`validations`.\n\n## Filters\n\nCreating a filter is simple, just create a function that calls the next filter\nin the stack. Here is a simple filter that just logs the record to the console.\n\n    var log = function(record, next){\n      console.log(record)\n      next(record)\n    }\n\nNow that we have a `filter` we put it in our model where we want it to be\ncalled. There are four different places within the lifecycle of a call that the\nfilter can be called.\n\n    var store = new Thug({\n      filters: {\n        in             : [],\n        beforeValidate : [],\n        beforeWrite    : [],\n        out            : []\n      }\n    })\n\n### `in` filters\n\n`in` filters are ran when the `set` and `valid` functions are first called.\nThis is useful when black-listing or white-listing properties on the record\nbefore the `validations` are ran.\n\n### `beforeValidate` filters\n\n`beforeValidate` filters are called immediately prior to `validations` being called\nbut after the `read` function is called in the cases where there is and\n`identifier` passed in. This is were you will do most of your heavy lifting\nin constructing your object data before going to the store such as setting a\ntimestamp, generating a uuid or creating a hash based on a password.\n\n### `beforeWrite` filters\n\n`beforeWrite` filters are ran immediately after `validations` are ran but still\nbefore the `write` function is called. This is the last opportunity to clean\nthe data up before storing the record. For example, you may want to delete a\nnaked password.\n\n### `out` filters\n\n`out` filters are ran immediately after the `write` function is ran. This is\nyour opportunity to clean the data up before returning to the client.\n\n## Validations\n\nA validation is a function that takes the arguments `field`, `record`,\n`errors`, `callback`. \n\n    var noBob = function(field, record, errors, callback){\n      if(record[field] === \"Bob\") errors.push(\"cannot be Bob\")\n      next()\n    }\n\nTo use this validation, add to the field you would like to validate on.\n\n    var store = new Thug({\n      validations:{\n        name: [noBob]\n      }\n    })\n\nNow if we were to attempt to set an object in the store that has a name of\n\"Bob\". We will get an error object back and the object will not be saved.\n\n    store.set({ name: \"Bob\" }, function(errors, record){\n      console.log(errors)\n    })\n\nThe errors object will look like this...\n\n    {\n      messages: [\"name cannot be Bob\"],\n      details: {\n        name: [\"cannot be Bob\"]\n      }\n    }\n\n## API\n\n### `set([identifier,] record, callback)`\n\n#### Lifecycle of a `set()` request\n\n  1. record is passed through `in` filters\n  2. `read` is called (if identifier is present)\n  3. record is passed through `beforeValidate` filters\n  4. `validations` are ran\n\nIf record fails validation, we return back to the client. otherwise continue...\n\n  5. record is passed through `beforeWrite` filters\n  6. `write` is called\n  7. record is passed through `out` filters\n  8. fires callback\n    \n### `validate([identifier,] record, callback)`\n\nThe `validate` call is a subset of `set`. It fires the callback after validations\nare ran but does not perform the beforeWrite filters nor call the `write` function.\n\n#### Lifecycle of a `valid()` request\n\n  1. record is passed through `in` filters\n  2. `read` is called (if identifier is present)\n  3. record is passed through `beforeValidate` filters\n  4. `validations` are ran\n  5. fires callback\n    \n### `get(identifier, callback)`\n\nThe `get` function calls the `read` function and passes the record through the\n`out` filters.\n\n#### Lifecycle of a `get()` request\n\n  1. `read` is called\n  2. if record is found, it is passed through `out` filters\n  3. fires callback\n\n\nCopyright 2012 Chloi Inc.\nAll rights reserved.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n",
  "_id": "thug@0.3.2",
  "dist": {
    "shasum": "d1fe89648e0de4ef0cd6de4a5fd106688154e353"
  },
  "_from": "thug@0.3.2"
}
